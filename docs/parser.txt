Like most mainstream languages, Tl considers it prudent to make a strict distinction between 
top-level declarations and functions' internals. This is necessary to support free order of function 
declarations in a file.

The layout of AST data after parsing a file goes like this:

1. All the const non-function declarations (and of course, at top-level only immutables are allowed)
2. All the signatures of top-level functions
3. Array of bodies of top-level functions

Name resolution always (at top-level and inside a function) proceeds top to bottom. This implies that:

- in a const declaration, it's forbidden to call any functions from same file. External functions are okay.

- in any  function (top-level or nested), it's allowed to call any top-level function and to reference any const 
from the same file

- in a nested function, it's allowed to call any top level func, any nested function that is lexically before
the current point, and to reference any top-level const as well as any local variable that is lexically before
current point

An OK example:

    foo = def(:
        bar()    -- bar is a top-level function, so it's in scope despite being defined lower below
    )

    (.f bar ()
        ; something
        x = 10
        fn nested(n Int)(:
        )
        :foo 
        x:nested    
    )

A bad example:

    fn bar()(:
        x = 10
        x:nested    -- nested function's definition is lexically after this point, so it's not in scope yet
        fn nested(n Int)(:
        )            
    )






Type layout for normal types (sums, structs, functions) is pentapartite:

[total size][nameId][tag](member names)(member types)

1. total size = 1 Int holding the number of ints of all the following data
2. tag = 8 bits of 0, 8 bits of type-arity, 8 bits of depth, 8 bits of sort

- sort = "the type of the type" = is it a function or a struct or a sum type?
- type-arity = the number of type parameters this type takes (0 if it's a concrete type)
- depth = the number of fields a struct has, or the number of variants a sum type has, or the arity of a function type

3. member names = list of nameIds of struct fields, sum type variants, or function parameters

4. member types = list of references to types of each member, plus (for function types) an extra typeId at end.

- reference to type = for single-param types, 8 bits that tell which one of this type's parameters is applied, and 
24 bits of typeInd. For all other types, it's 8 bits of 0 and 24 bits of typeInd

Primitive types are represented as just a single 0.

Examples:

"Int"
[0]

"MyStruct = def(id Int name String)"
[5][sort = struct, depth = 2, arity = 0]("id" "name")(Int String)


"MyStruct = def(id Int payload L(?A) dict Dict(String P(?A ?B))"
[][sort = struct, depth = 3, arity = 2]("id" "payload" "dict")(Int (0 L) (Ref1))
where Ref1 is the typeInd of the type
[][sort = concretization, depth = 2, arity = 0](Dict/2 String P/2 0 1)


-----------------------------------------------------
Type layout for types of the sort "concretization":

Max type arity = 254 (not 255!)

[total size][typeId/paramId][tag](Full type expression in prefix form, with arities)

- typeId = id of the original type if it's known, and paramId if a param
- The tag has sort = "concretization", depth = 0
- The type expression is made of single or double-int parts with the following structure: 
    - if it's 8 bits of 0, then next 24 bits are the typeInd of a concrete type
    - if it's 8 bits of != -1, then those 8 bits are the arity then next 24 bits are the typeInd of a concrete type
    - if it's 8 bits of -1, then it's a type param, and next 24 bits are: 8 bits 0, 8 bits arity, 8 bits of type param index

Examples:

Map(?T ?U) inside Foo(...?T ?U) will have the layout
[][concretization arity = 0](2/Map -1/0/0/0 -1/0/0/1)

Map(String ?U) inside Foo(...?T ?U) will have the layout
[][concretization arity = 0](2/Map 0/String -1/0/0/1)

?M(String ?T) inside Foo(... ?T ?M) will have the layout
[][concretization arity = 0](-1/0/2/1 0/String -1/0/0/0)



