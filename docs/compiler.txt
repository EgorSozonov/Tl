COMPILER MEMORY
-----------------------    

1) a = Arena for the results
AST (i.e. the resulting code)
Entities
Types

2) aTmp = Arena for the temporary stuff (like the backtrack). Freed after end of parsing

3) ScopeStack (temporary, but knows how to free parts of itself, so in a separate arena)

WORKFLOW
-----------------------    
    
The "stringTable" is frozen: it was filled by the lexer. The "bindings" table is growing
with every new assignment form encountered. "Nodes" is obviously growing with the new AST nodes
emitted.
Any new span (scope, expression, assignment etc) means 
- pushing a ParseFrame onto the "backtrack" stack
- if the new frame is a lexical scope, also pushing a scope onto the "scopeStack"
The end of a span means popping from "backtrack" and also, if needed, popping from "scopeStack".
In the parser, all non-functions are bound to Entities, but functions are instead bound to Overloads.
Binding ids go: 0, 1, 2... Overload ids go: -2, -3, -4...
Those overloads are used for counting how many functions for each name there are.
Then they are resolved at the stage of the typer, after which there are only the Entities.

DATA & FORMATS    
-----------------------    
    
 1. sourceCode = source code prepended with {standardText} 

 2. inpLength = for convenience, the length of source code in bytes

 3. langDef = global definitions of the language for the lexer & parser

 4. tokens = tokens emitted by the lexer

 5. newlines = list of byte-indices of newlines for linenumber calculation

 6. numeric = [aTmp] scratch space for numbers

 7. lexBtrack = [aTmp] stack for keeping track of lexing spans

 8. stringTable = table of unique strings from sourceCode. Contains only the 
startByte of each string
    
 9. stringDict = A hash table for quickly deduplicating strings. Points into stringTable    
    
10. lastClosingPunctInd = temp, the index of the last encountered closing punctuation sign, used for statement length
   
11. toplevels = all top-level definitions

12. backtrack = [aTmp] stack of {ParseFrame} for keeping track of parsing spans

13. scopeStack = stack of currently active scopes (for active bindings tracking)

14. activeBindings = [aTmp] Current entities and overloads in scope. -1 means
"inactive". Its length = stringTable length.
1) Vars are < BIG, nameId (index into stringTable) -> bindingId
2) Type bindings are < BIG, nameId -> bindingId
3) Type parameter bindings are < -1, nameId => (-paramId - 2) 
4) Function bindings are < -1, nameId -> (-overloadId - 2). So a negative value less than -1 means "the function is active"
5) Variables that have been assigned a definite overload are >= BIG and point to the functions table, i.e. nameId -> (functionId + BIG). These, top-level functions and top-level constants are the only immutable vars.

(BIG = 70million)

Structure of activeBindings after the {initializeParser}:

    a. names for operators ({countOperators} of them) - permanently in scope
    b. names for primitive types, from Int to Void - permanently in scope
    c. parsed names - temporarily or permanently in scope 

15. loopCounter = used to assign unique labels to loops during parsing. Restarts at function start

16. nodes = list of AST nodes emitted by the parser

17. monoCode = list of function monomorphizations. AST nodes stored in a single
list, with indices stored in [monoIds]
    
18. monoIds = list of ids
Format: [length of what follows (in units of int)](typeId [fnMono]) 
TypeIds are concrete

19. entities = list of entites for local variables and non-function constants
    
21. entImportedZero = the index of the first imported entity    
    
22. overloads = links from type to [functions] and [fnMonoIds] 
Format: (namedGroups)
    
namedGroup is all the overloads of a single name 
    
namedGroup = [count of what follows, so countOveroads*3]
             (sorted outer types)(ref types    )(refs        )
             |<---countOuter--->||<-countRefs->||<-countRefs->
overload finding algorithm = 
1) binary-search first countOuter for the outerType 
2) for result j, get the ref index r from (j + countOuter), and the sentinel s from next
cell (or use s = countRefs if the cell's last)
2a) if r or s are negative, transform them via (-x - 1) 
3) full search from r to s for the full (not outer) type
4) if found result f (r <= f < s), then the sweet ref is at index
    2*countOuter + countRefs + f
  The ref will either be a functionId (if r was non-negative at 2a) or (-monoId - 1)  
    
prefixTypeGroup = [1 bit flag + 31 bits length (in units of int)]
[prefixType](actualOverloads)
    
actualOverload = (typeId [function]) if flag false, (typeId [fnMonoId]) if true
    
For (typeId functionId) case, typeIds are concrete. For (typeId [fnMonoId] it is 
sorPartial.
    
23. types = list of all the unique type data. See docs/typeLayout.txt    
    
24. typesDict = hash dictionary of types to keep them unique

25. imports = [aTmp] imported function overloads
    
26. countOperatorEntities = ?

27. countNonparsedEntities = the index of the first parsed (as opposed to being built-in or imported) entity
    
28. expStack = [aTmp] temporary scratch space for type checking/resolving an expression    
    
29. typeStack = [aTmp] temporary scratch space for type params. Entries: [nameId arity]    
    
30. tempStack = [aTmp]  a very temporary scratch space for stuff    
    
31. rawOverloads = [aTmp] a multilist used during overloads
construction.
Format: for every nameId, including the operators, contains
[len cap](list of (typeId ref)). Refs are positive
for [entities] and negative (-x - 1) for [monoIds]

32. i = current index into whatever we're reading (source code, tokens)    
    
33. wasError = flag if the compiler has encountered an error    
    
34. errMsg = error message if wasError is true, NULL otherwise 
    
35. a = main arena, created for each module being compiled
    
36. aTmp = temporary arena, emptied after lexing and after parsing
    
