COMPILER MEMORY
-----------------------    

1) a = Arena for the results
AST (i.e. the resulting code)
Entities
Types

2) aTmp = Arena for the temporary stuff (like the backtrack). Freed after end of parsing

3) ScopeStack (temporary, but knows how to free parts of itself, so in a separate arena)

WORKFLOW
-----------------------    
    
The "stringTable" is frozen: it was filled by the lexer. The "bindings" table is growing
with every new assignment form encountered. "Nodes" is obviously growing with the new AST nodes
emitted.
Any new span (scope, expression, assignment etc) means 
- pushing a ParseFrame onto the "backtrack" stack
- if the new frame is a lexical scope, also pushing a scope onto the "scopeStack"
The end of a span means popping from "backtrack" and also, if needed, popping from "scopeStack".
In the parser, all non-functions are bound to Entities, but functions are instead bound to Overloads.
Binding ids go: 0, 1, 2... Overload ids go: -2, -3, -4...
Those overloads are used for counting how many functions for each name there are.
Then they are resolved at the stage of the typer, after which there are only the Entities.

DATA & FORMATS    
-----------------------    
    
 1. sourceCode = source code prepended with {standardText} 

 2. inpLength = for convenience, the length of source code in bytes

 3. langDef = global definitions of the language for the lexer & parser

 4. tokens = tokens emitted by the lexer

 5. newlines = list of byte-indices of newlines for linenumber calculation

 6. numeric = [aTmp] scratch space for numbers

 7. lexBtrack = [aTmp] stack for keeping track of lexing spans

 8. stringTable = table of unique strings from sourceCode. Contains only the 
startByte of each string
    
 9. stringDict = A hash table for quickly deduplicating strings. Points into stringTable    
    
10. lastClosingPunctInd = temp, the index of the last encountered closing punctuation sign, used for statement length
   
11. toplevels = all top-level definitions

12. backtrack = [aTmp] stack of {ParseFrame} for keeping track of parsing spans

13. scopeStack = stack of currently active scopes (for active bindings tracking)

14. activeBindings = [aTmp] Current entities and overloads in scope. -1 means
"inactive". Its length = stringTable length.
Vars are nameId (index into stringTable) -> bindingId
Type bindings are nameId -> bindingId
Type parameter bindings are nameId => (-paramId - 2) 
Function bindings are nameId -> (-overloadId - 2). So a negative value less than -1 means "the function is active"

15. loopCounter = used to assign unique labels to loops during parsing. Restarts at function start

16. nodes = list of AST nodes emitted by the parser

17. fnMonos = list of function monomorphizations. AST nodes stored in a single
list, with indices stored in [fnMonoInds]
    
18. fnMonoIds = list of ids

19. entities = list of entites for local variables and non-function constants
    
20. functions = list of ints for each function definition.
Format: [length of what follows][typeId][flags = 30 bits 0, 1 bit if it's public, 
1 bit if it has an exception handler](sorted list of nameIds of fn parameters)
    
21. entImportedZero = the index of hte first imported entity    
    
22. overloadIds = [aTmp] Initially, a growing array of counts of all fn names encountered. Upper 16 bits contain concrete count, lower 16 bits total count. After {createOverloads}, contains overload indices into the "overloads" table.
    
23. overloads = links from type to functions and fnMonoIds 
    
24. types = list of all the unique type data. See docs/typeLayout.txt    
    
25. typesDict = hash dictionary of types to keep them unique

26. imports = [aTmp] imported function overloads
    
27. countOperatorEntities = ?

28. countNonparsedEntities = the index of the first parsed (as opposed to being built-in or imported) entity
    
29. expStack = [aTmp] temporary scratch space for type checking/resolving an expression    
    
30. typeStack = [aTmp] temporary scratch space for type params. Entries: [nameId arity]    
    
31. tempStack = [aTmp]  a very temporary scratch space for stuff    
    
32. i = current index into whatever we're reading (source code, tokens)    
    
33. wasError = flag if the compiler has encountered an error    
    
34. errMsg = error message if wasError is true, NULL otherwise 
    
35. a = main arena, created for each module being compiled
    
36. aTmp = temporary arena, emptied after lexing and after parsing
    
